class Solution {
public:
    //动态规划
    //思路: 我们需要从后往前分析, 这样比较好处理 * 的情况 (但是实际写代码的时候, 需要从前往后写, 因为后面的状态需要前面的状态来推导)
    //从后往前分析时, 一共会遇到3种情况     (下面我们的i-1实际上表示的就是第i个位置)
    //注意: 以下表述中, s如果可以被匹配, 则dp[i - 1][j - 1]; s如果不能被匹配, 则dp[i][j - 2];(*把前一个字符删了)
    //1. s[i - 1] == p[j - 1] ; 作为字符, 两个位置的字符直接匹配了
    //   dp[i][j] = dp[i - 1][j - 1];
    //2. p[j - 1] == '.'      ; p[j - 1]作为 '.' 符号, 万能匹配任何字符 (与情况1可以合并)
    //   dp[i][j] = dp[i - 1][j - 1];
    //3. p[j - 1] == '*', 此时需要看p[j - 2]和s[i - 1]的关系了, 它们有2种关系
    //  3.1     s[i - 1] == p[j - 2]    ; 此时说明这个*可以匹配任意次数
    //          dp[i][j] = dp[i][j - 2] || dp[i - 1][j - 2] || dp[i - 1][j];
    //  3.2     s[i - 1] != p[j - 2]    ; 此时只能让 * 匹配0次, 不然就false了
    //          dp[i][j] = dp[i][j - 2];
    bool isMatch(string s, string p) {
        //dp[i][j]: s的前i个字符 与 p的前j个字符是否能匹配
        vector<vector<bool>> dp(s.size() + 1, vector<bool>(p.size() + 1, false));
        dp[0][0] = true;    // 2个空串, 一定是匹配的
        for(int j = 1; j <= p.size(); ++j)  //考虑一下当s串为空串时, 此时p串的最后一位如果是*,那么它有可能与空串匹配 (这里将*的功能定义为匹配 0 次 前面的字符, 因为只有匹配0次才有可能满足空串)
        {
            if(p[j - 1] == '*'){
                dp[0][j] = dp[0][j - 2];
            }
        }

        for(int i = 1; i <= s.size(); ++i)
        {
            for(int j = 1; j <= p.size(); ++j)
            {
                //1/2. 两者本身能够匹配
                if(s[i - 1] == p[j - 1] || p[j - 1] == '.'){
                    dp[i][j] = dp[i - 1][j - 1];
                }//3. p[j - 1] == '*'   匹配0次, 匹配1次, 匹配多次
                else if(p[j - 1] == '*'){

                    if(s[i - 1] == p[j - 2] || p[j - 2] == '.'){
                    //3.1 此时, * 的前一位能够与s[i - 1]匹配上, 那么*的匹配次数可以为0次,1次,更多次
                        dp[i][j] = dp[i][j - 2] || dp[i - 1][j - 2] || dp[i - 1][j];
                    }
                    else{
                    //3.2 此时, * 的前一位不能有s[i - 1]匹配上, 那么*的匹配次数只能为0 (必须把前面的那个字符干掉)
                        dp[i][j] = dp[i][j - 2];
                    }

                }
            }
        }

        return dp[s.size()][p.size()];
    }
};